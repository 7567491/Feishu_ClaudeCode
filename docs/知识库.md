# 使用飞书机器人读取和生成知识库

根据我搜索到的信息，这里是**使用飞书机器人读取和生成知识库**的完整指南：

## 一、准备工作

### 1. 创建飞书应用
- 访问 [飞书开放平台](https://open.feishu.cn/)
- 创建"企业自建应用"
- 获取 `App ID` 和 `App Secret`

### 2. 申请必要权限（Scopes）

需要在应用权限管理中申请：

```
✅ 知识库相关权限：
- wiki:wiki:readonly          (读取知识库信息)
- wiki:wiki:read_content      (读取知识库内容)
- wiki:wiki                   (创建/编辑知识库)

✅ 文档相关权限：
- docx:document:readonly      (读取文档)
- docx:document               (创建/编辑文档)
- drive:drive:readonly        (读取云空间文件)
```

### 3. 获取知识库授权

⚠️ **关键步骤**：
- 知识库管理员需要在知识库设置中添加你的应用
- 打开知识库 → 点击右上角"分享" → 添加应用

## 二、核心概念

### 资源标识符

| 资源 | 标识符 | 示例 |
|------|--------|------|
| 知识库空间 | `space_id` | 从知识库 URL 获取 |
| 知识库节点 | `node_token` | 从节点 URL 获取 |
| 文档对象 | `obj_token` | 通过节点信息获取 |
| 对象类型 | `obj_type` | doc/sheet/bitable/docx |

### 获取 Token 的方法

```javascript
// 从URL获取 node_token
// 示例URL: https://xxx.feishu.cn/wiki/wikcnGqUhzR7zMXt5ZxlsPZ9OHB
// node_token = wikcnGqUhzR7zMXt5ZxlsPZ9OHB
```

## 三、读取知识库内容

### 步骤流程

```
1. 获取访问令牌 (tenant_access_token)
   ↓
2. 获取知识库列表 (获取 space_id)
   ↓
3. 获取知识库节点信息 (获取 node_token)
   ↓
4. 获取节点详情 (获取 obj_token 和 obj_type)
   ↓
5. 根据类型读取具体内容 (调用文档/表格 API)
```

### 示例代码（Node.js）

```javascript
import lark from '@larksuiteoapi/node-sdk';

// 1. 初始化客户端
const client = new lark.Client({
  appId: 'your_app_id',
  appSecret: 'your_app_secret',
  appType: lark.AppType.SelfBuild
});

// 2. 获取知识库列表
async function getWikiSpaces() {
  const res = await client.wiki.space.list({
    params: { page_size: 20 }
  });

  console.log('知识库列表:', res.data.items);
  return res.data.items;
}

// 3. 获取节点信息
async function getNodeInfo(spaceId, nodeToken) {
  const res = await client.wiki.spaceNode.get({
    path: {
      space_id: spaceId,
      node_token: nodeToken
    }
  });

  const { obj_token, obj_type } = res.data.node;
  console.log('节点信息:', obj_token, obj_type);
  return { obj_token, obj_type };
}

// 4. 读取文档内容（以 docx 为例）
async function getDocContent(documentId) {
  const res = await client.docx.documentRawContent.get({
    path: { document_id: documentId }
  });

  console.log('文档内容:', res.data.content);
  return res.data.content;
}

// 5. 完整流程
async function readWikiContent(spaceId, nodeToken) {
  try {
    // 获取节点信息
    const { obj_token, obj_type } = await getNodeInfo(spaceId, nodeToken);

    // 根据类型读取内容
    if (obj_type === 'docx') {
      return await getDocContent(obj_token);
    } else if (obj_type === 'doc') {
      // 使用旧版文档API
      const res = await client.doc.content({
        path: { doc_token: obj_token }
      });
      return res.data.content;
    }
  } catch (error) {
    console.error('读取失败:', error);
  }
}
```

## 四、生成知识库内容

### 1. 创建知识库节点

```javascript
// 在知识库中创建新节点
async function createWikiNode(spaceId, title, objType = 'docx') {
  const res = await client.wiki.spaceNode.create({
    path: { space_id: spaceId },
    data: {
      obj_type: objType,  // docx/doc/sheet/bitable
      title: title,
      node_type: 'origin', // origin/shortcut
      parent_node_token: '' // 空表示放在根节点
    }
  });

  console.log('创建成功:', res.data);
  return res.data;
}
```

### 2. 创建文档并添加到知识库

```javascript
// 完整流程：创建文档 + 添加内容 + 放入知识库
async function createWikiDocument(spaceId, title, markdownContent) {
  // Step 1: 创建空白文档
  const docRes = await client.docx.document.create({
    data: { title: title }
  });

  const documentId = docRes.data.document.document_id;

  // Step 2: 添加内容（转换 markdown 为 blocks）
  const blocks = convertMarkdownToBlocks(markdownContent);

  // 获取页面 block
  const blocksRes = await client.docx.documentBlock.list({
    path: { document_id: documentId },
    params: { document_revision_id: -1 }
  });

  const pageBlock = blocksRes.data.items.find(item => item.parent_id === '');

  // 批量添加内容
  await client.docx.documentBlockChildren.create({
    path: {
      document_id: documentId,
      block_id: pageBlock.block_id
    },
    data: {
      children: blocks,
      index: -1
    }
  });

  // Step 3: 将文档添加到知识库
  const nodeRes = await client.wiki.spaceNode.create({
    path: { space_id: spaceId },
    data: {
      obj_type: 'docx',
      obj_token: documentId,
      title: title,
      node_type: 'origin'
    }
  });

  console.log('文档已添加到知识库:', nodeRes.data);
  return nodeRes.data;
}
```

## 五、与 AI 集成（可选）

### 方式1：Dify 集成

```bash
# 在 Dify 中配置飞书文档数据源
1. 知识库设置 → 数据源 → 飞书文档
2. 输入 App ID 和 App Secret
3. 授权访问知识库
4. 自动同步文档内容
```

### 方式2：FastGPT 集成

```yaml
# FastGPT 配置文件
feishu:
  app_id: "your_app_id"
  app_secret: "your_app_secret"
  wiki_space_id: "your_space_id"
```

## 六、常见问题

### Q1: 如何获取 space_id？
**A**: 从知识库 URL 中提取，或调用知识库列表 API

### Q2: 权限不足怎么办？
**A**:
1. 检查应用是否申请了相应权限
2. 检查知识库管理员是否已添加应用
3. 使用 `user_access_token` 而非 `tenant_access_token`

### Q3: 如何批量处理？
**A**: 使用分页参数，每次最多获取 50 条记录

```javascript
let hasMore = true;
let pageToken = '';

while (hasMore) {
  const res = await client.wiki.spaceNode.list({
    path: { space_id: spaceId },
    params: {
      page_size: 50,
      page_token: pageToken
    }
  });

  hasMore = res.data.has_more;
  pageToken = res.data.page_token;

  // 处理数据...
}
```

## 参考资源

- 📘 [飞书开放平台文档](https://open.feishu.cn/document)
- 📦 [Node.js SDK](https://www.npmjs.com/package/@larksuiteoapi/node-sdk)
- 🔧 [API 调试台](https://open.feishu.cn/api-explorer)

这套方案可以完整实现飞书知识库的读取和生成功能！

---

# 小六 × 飞书知识库集成项目策划

## 一、飞书知识库配额总结

### ✅ 免费版配额（非常充足！）

| 类型 | 限制 | 说明 |
|------|------|------|
| **云空间存储** | 100GB (认证后) | 共享存储（文档/消息/妙记） |
| **知识库数量** | ✅ **无限制** | V4.11后取消限制 |
| **总页面数** | 40万个 | 单个知识库可容纳 |
| **子页面数** | 2,000个/页面 | 每个节点下 |
| **层级深度** | 100层 | 足够深的目录结构 |
| **协作成员** | 500位 | 每个知识库 |
| **单文件上传** | 200M | Markdown文档通常<1M |
| **同时阅读** | 5,000人 | 并发访问 |

### 📊 容量估算

```
单个项目文档占用:
- need.md: ~2KB
- design.md: ~3KB
- plan.md: ~2KB
- readme.md: ~3KB
总计: ~10KB/项目

1000个用户 × 10个项目 × 10KB = 100MB
→ 仅占用100GB的 0.1%

结论: 容量完全不是问题！
```

---

## 二、项目架构设计

### 🏗️ 知识库结构方案

#### 方案A: 单一知识库（推荐）

```
📚 小六知识库
├── 📁 用户项目
│   ├── 📁 张璐 (ZL)
│   │   ├── 📄 ZL_11_扫雷
│   │   │   └── readme.md
│   │   ├── 📄 ZL_32_简易博客
│   │   │   ├── need.md
│   │   │   ├── design.md
│   │   │   ├── plan.md
│   │   │   └── readme.md
│   │   └── ...
│   ├── 📁 李四 (LS)
│   └── 📁 王五 (WW)
├── 📁 项目模板库
│   ├── 📄 前端小游戏模板
│   ├── 📄 前端小应用模板
│   └── 📄 全栈应用模板
└── 📁 使用统计
    └── 📄 项目创建记录

优势:
✅ 管理简单，单一入口
✅ 便于全局搜索
✅ 权限统一管理
✅ 不会超过40万页面限制（预计<1万页面）
```

#### 方案B: 多知识库（备选）

```
📚 小六-用户项目
📚 小六-模板库
📚 小六-统计报表

优势: 权限分离
劣势: 管理复杂，搜索分散
```

**决策：采用方案A**

---

## 三、功能设计

### 🎯 核心功能（MVP - 第一版）

#### 1. 自动归档 Readme

```python
# 触发时机
用户创建项目 → 小六完成开发 → 生成readme.md → 自动上传知识库

# 实现流程
def archive_readme(user_data, project_data, readme_content):
    """
    归档项目README到知识库

    Args:
        user_data: {username: "张璐", prefix: "ZL"}
        project_data: {choice: "32", app_name: "简易博客"}
        readme_content: markdown内容
    """
    # 1. 创建/获取用户文件夹节点
    user_folder = get_or_create_user_folder(user_data['username'])

    # 2. 创建文档
    doc_title = f"{user_data['prefix']}_{project_data['choice']}_{project_data['app_name']}"
    doc = await feishu_client.createDocumentFromMarkdown(
        title=doc_title,
        content=readme_content
    )

    # 3. 添加到知识库
    node = await feishu_client.wiki.spaceNode.create({
        space_id: WIKI_SPACE_ID,
        parent_node_token: user_folder.node_token,
        obj_type: 'docx',
        obj_token: doc.document_id,
        title: doc_title
    })

    # 4. 返回知识库链接
    return f"https://feishu.cn/wiki/{node.node_token}"
```

#### 2. 知识库链接回复

```python
# 用户体验
用户: 11
机器人: ✅ 已为【张璐】创建项目：ZL_11-扫雷

📋 发送给小六的任务：...

📚 项目文档将自动归档到知识库
   → 完成后会发送知识库链接

(小六完成开发后)
机器人:
🎉 项目【ZL_11-扫雷】开发完成！

📚 项目文档已归档：
https://feishu.cn/wiki/xxxxx

可通过以下方式查看：
• 回复"我的项目"查看所有项目
• 点击上方链接直接访问
```

#### 3. 查询我的项目

```python
# 用户输入
用户: 我的项目
用户: 查看项目
用户: 项目列表

# 机器人回复
机器人:
📚 您的项目列表 (共3个)

【前端小游戏】
🎮 ZL_11-扫雷
   📅 2025-01-15
   🔗 https://s.linapp.fun/zl_11_扫雷.html
   📚 文档: https://feishu.cn/wiki/xxxxx

【全栈应用】
📝 ZL_32-简易博客
   📅 2025-01-10
   🔗 http://zl_32.linapp.fun
   📚 文档: https://feishu.cn/wiki/yyyyy

💡 提示: 点击文档链接查看完整开发文档
```

---

### 🚀 进阶功能（第二版）

#### 4. 归档全部文档

```python
# 全栈项目归档4个文档
- need.md (需求文档)
- design.md (架构设计)
- plan.md (开发计划)
- readme.md (项目说明)

# 知识库结构
ZL_32_简易博客/
├── 📄 需求文档
├── 📄 架构设计
├── 📄 开发计划
└── 📄 项目说明
```

#### 5. 项目模板库

```python
# 预置9个应用的最佳实践模板
用户: 模板库
机器人:
📖 项目模板库

【前端小游戏】
🎮 扫雷游戏最佳实践
🐍 贪吃蛇优化方案
♟️ 五子棋算法解析

【前端小应用】
🧮 计算器UI设计
🎨 绘画板技术要点
⏰ 倒计时器动画实现

【全栈应用】
✅ 任务清单架构模式
📝 博客系统数据建模
📅 日历应用技术选型
```

#### 6. 统计与分析

```python
# 知识库数据看板
用户: 统计

机器人:
📊 小六使用统计

👥 总用户数: 1,245
📁 总项目数: 5,830
📚 知识库文档: 23,320篇

🔥 热门应用TOP3:
1. 扫雷游戏 (820次)
2. 简易博客 (650次)
3. 计算器 (580次)

📅 本月新增: 230个项目
```

---

## 四、技术实现方案

### 📦 依赖和权限

#### 需要申请的飞书权限

```
✅ 已有权限:
- im:message (发送消息)
- contact:user.base:readonly (获取用户信息)

🆕 需要新增:
- wiki:wiki (创建/编辑知识库) ⭐核心
- wiki:wiki:readonly (读取知识库)
- docx:document (创建/编辑文档) ⭐核心
- docx:document:readonly (读取文档)
```

#### Python依赖包

```python
# requirements.txt 新增
lark-oapi==1.2.x  # 飞书SDK（已有）

# 无需新增依赖！现有SDK已支持
```

---

### 🔧 核心代码模块

#### 1. Wiki管理器 (`wiki_manager.py`)

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
飞书知识库管理器
"""

import logging
from feishu_client import feishu_client
from config import WIKI_SPACE_ID, WIKI_ROOT_NODE_TOKEN

logger = logging.getLogger(__name__)


class WikiManager:
    """知识库管理器"""

    def __init__(self):
        self.client = feishu_client
        self.space_id = WIKI_SPACE_ID  # 配置文件中设置
        self.user_folders = {}  # 缓存用户文件夹节点

    async def get_or_create_user_folder(self, username, user_prefix):
        """
        获取或创建用户文件夹节点

        Args:
            username: 用户名（如"张璐"）
            user_prefix: 用户前缀（如"ZL"）

        Returns:
            dict: {node_token, url}
        """
        # 检查缓存
        cache_key = f"{user_prefix}_{username}"
        if cache_key in self.user_folders:
            return self.user_folders[cache_key]

        try:
            # 创建用户文件夹文档
            folder_title = f"{username} ({user_prefix})"
            doc = await self.client.createDocument(folder_title)

            # 添加到知识库
            node = await self.client.wiki.spaceNode.create({
                'space_id': self.space_id,
                'parent_node_token': WIKI_ROOT_NODE_TOKEN,
                'obj_type': 'docx',
                'obj_token': doc['document_id'],
                'title': folder_title,
                'node_type': 'origin'
            })

            result = {
                'node_token': node['node_token'],
                'url': f"https://feishu.cn/wiki/{node['node_token']}"
            }

            # 缓存
            self.user_folders[cache_key] = result
            logger.info(f"创建用户文件夹: {folder_title}")

            return result

        except Exception as e:
            logger.error(f"创建用户文件夹失败: {e}")
            raise

    async def archive_project_readme(self, user_data, project_data, readme_content):
        """
        归档项目README到知识库

        Args:
            user_data: {username, prefix}
            project_data: {choice, app_name}
            readme_content: markdown内容

        Returns:
            str: 知识库文档URL
        """
        try:
            # 1. 获取用户文件夹
            user_folder = await self.get_or_create_user_folder(
                user_data['username'],
                user_data['prefix']
            )

            # 2. 创建项目文档
            doc_title = f"{user_data['prefix']}_{project_data['choice']}_{project_data['app_name']}"
            doc = await self.client.createDocumentFromMarkdown(
                title=doc_title,
                content=readme_content
            )

            # 3. 添加到用户文件夹下
            node = await self.client.wiki.spaceNode.create({
                'space_id': self.space_id,
                'parent_node_token': user_folder['node_token'],
                'obj_type': 'docx',
                'obj_token': doc['document_id'],
                'title': doc_title,
                'node_type': 'origin'
            })

            wiki_url = f"https://feishu.cn/wiki/{node['node_token']}"
            logger.info(f"项目归档成功: {doc_title} → {wiki_url}")

            return wiki_url

        except Exception as e:
            logger.error(f"归档项目失败: {e}", exc_info=True)
            # ⚠️ 不抛出异常，避免影响主流程
            return None

    async def get_user_projects(self, user_prefix):
        """
        获取用户的所有项目

        Args:
            user_prefix: 用户前缀（如"ZL"）

        Returns:
            list: [{title, url, create_time}, ...]
        """
        try:
            # 查询用户文件夹下的所有子节点
            cache_key = f"{user_prefix}_*"
            user_folder = self.user_folders.get(cache_key)

            if not user_folder:
                logger.warning(f"用户文件夹不存在: {user_prefix}")
                return []

            # 获取子节点列表
            nodes = await self.client.wiki.spaceNode.list({
                'space_id': self.space_id,
                'parent_node_token': user_folder['node_token']
            })

            projects = []
            for node in nodes.get('items', []):
                projects.append({
                    'title': node['title'],
                    'url': f"https://feishu.cn/wiki/{node['node_token']}",
                    'create_time': node.get('create_time', '')
                })

            return projects

        except Exception as e:
            logger.error(f"获取用户项目失败: {e}")
            return []


# 全局单例
wiki_manager = WikiManager()
```

#### 2. 配置更新 (`config.py`)

```python
# 知识库配置
WIKI_SPACE_ID = "your_space_id"  # 知识库空间ID（需创建）
WIKI_ROOT_NODE_TOKEN = "your_root_node_token"  # 根节点Token

# 功能开关
ENABLE_WIKI_ARCHIVE = True  # 是否启用知识库归档
WIKI_ARCHIVE_MODE = "readme_only"  # readme_only | full_docs
```

#### 3. 消息处理器集成

```python
# message_handler.py 中添加

async def _handle_user_choice(self, open_id, text, project_name, username, chat_id, chat_type):
    """处理用户选择（11-33）"""
    # ... 原有代码 ...

    # 调用小六API
    success = self.feishu.call_xiaoliu_api(clean_command, chat_id)

    # 🆕 知识库归档逻辑（异步，不阻塞）
    if success and ENABLE_WIKI_ARCHIVE:
        asyncio.create_task(
            self._archive_to_wiki_later(
                user_data={'username': username, 'prefix': user_prefix},
                project_data={'choice': choice, 'app_name': app_name},
                chat_id=chat_id,
                chat_type=chat_type
            )
        )

    # ... 原有代码 ...

async def _archive_to_wiki_later(self, user_data, project_data, chat_id, chat_type):
    """
    延迟归档到知识库（等待小六完成）
    """
    try:
        # 等待小六生成readme（轮询或webhook）
        readme_content = await self._wait_for_readme(project_data)

        if not readme_content:
            logger.warning("未获取到readme内容，跳过归档")
            return

        # 归档到知识库
        wiki_url = await wiki_manager.archive_project_readme(
            user_data, project_data, readme_content
        )

        if wiki_url:
            # 发送知识库链接
            msg = f"📚 项目【{project_data['choice']}-{project_data['app_name']}】文档已归档\n{wiki_url}"
            self._send_message(open_id, msg, chat_id, chat_type)

    except Exception as e:
        logger.error(f"延迟归档失败: {e}")
```

---

## 五、实施计划

### 📅 分阶段实施（敏捷迭代）

#### 🎯 Phase 1: 基础搭建（3天）

**Day 1: 环境准备**
- [ ] 创建飞书知识库空间
- [ ] 申请wiki相关权限（提交审核）
- [ ] 配置WIKI_SPACE_ID等参数
- [ ] 测试创建文档API

**Day 2: 核心功能**
- [ ] 实现`WikiManager`类
- [ ] 实现`get_or_create_user_folder`
- [ ] 实现`archive_project_readme`
- [ ] 单元测试

**Day 3: 集成测试**
- [ ] 集成到`message_handler`
- [ ] 完整流程测试
- [ ] 错误处理优化
- [ ] 日志完善

**交付物**: MVP版本（仅归档readme）

---

#### 🚀 Phase 2: 功能完善（2天）

**Day 4: 增强功能**
- [ ] 实现"查询我的项目"
- [ ] 优化知识库链接展示
- [ ] 添加项目统计功能
- [ ] 缓存优化

**Day 5: 用户体验**
- [ ] 异常场景处理
- [ ] 性能优化（异步归档）
- [ ] 友好提示文案
- [ ] 灰度测试

**交付物**: 完整版V1.0

---

#### ⭐ Phase 3: 高级特性（选做）

**Week 2**
- [ ] 归档全部文档（need/design/plan/readme）
- [ ] 项目模板库
- [ ] 数据统计看板
- [ ] 知识库搜索功能

---

### 🎯 成功指标

| 指标 | 目标 | 说明 |
|------|------|------|
| **归档成功率** | >95% | 95%的项目成功归档 |
| **响应延迟** | <3秒 | 归档操作不阻塞用户 |
| **存储占用** | <500MB | 1000个项目场景 |
| **用户满意度** | >4.5/5 | 问卷调查 |
| **查询使用率** | >30% | 用户主动查询项目 |

---

## 六、风险管理

### ⚠️ 风险识别与应对

| 风险 | 影响 | 概率 | 应对措施 |
|------|------|------|----------|
| **权限审核不通过** | 🔴高 | 30% | Plan B: 本地文件库 |
| **跨租户权限受限** | 🟡中 | 50% | 仅支持同租户用户 |
| **知识库API限流** | 🟡中 | 20% | 重试+指数退避 |
| **存储配额不足** | 🟢低 | 5% | 监控+清理 |
| **小六readme未生成** | 🟡中 | 10% | 超时处理+手动补传 |

### 🛡️ Plan B方案

```python
# 如果知识库权限被拒，降级为本地文档库
if not WIKI_PERMISSION_GRANTED:
    # 方案1: 生成本地HTML索引
    save_to_local_html_library()

    # 方案2: 发送文档到飞书云文档（无需wiki权限）
    send_as_feishu_doc()

    # 方案3: 存储到GitHub Pages
    push_to_github_pages()
```

---

## 七、成本与收益

### 💰 成本估算

| 类型 | 成本 | 说明 |
|------|------|------|
| **开发时间** | 5人天 | Phase 1+2 |
| **飞书配额** | ¥0 | 免费版足够 |
| **服务器** | ¥0 | 复用现有 |
| **维护成本** | 1人天/月 | 监控+优化 |

**总计**: 初期5人天，运营¥0/月

### 📈 收益分析

| 收益 | 量化 | 说明 |
|------|------|------|
| **知识沉淀** | ⭐⭐⭐⭐⭐ | 永久保存5,000+项目 |
| **用户留存** | +20% | 查看历史项目增加粘性 |
| **学习价值** | ⭐⭐⭐⭐⭐ | 新人参考最佳实践 |
| **品牌提升** | ⭐⭐⭐⭐ | 技术领先性展示 |
| **协作效率** | +30% | 团队知识共享 |

**ROI**: 极高（成本低，收益显著）

---

## 八、下一步行动

### ✅ 立即执行（今天）

1. **创建飞书知识库空间**
   ```bash
   # 手动操作
   1. 打开飞书工作台
   2. 知识库 → 创建知识库
   3. 命名："小六知识库"
   4. 获取space_id（从URL提取）
   ```

2. **申请API权限**
   ```bash
   # 飞书开放平台
   1. 应用管理 → 权限管理
   2. 添加权限：
      - wiki:wiki
      - wiki:wiki:readonly
      - docx:document
      - docx:document:readonly
   3. 提交审核（预计1-3天）
   ```

3. **准备代码框架**
   ```bash
   cd /home/ccp/teacher
   touch wiki_manager.py
   # 复制上述代码模板
   ```

### 📋 本周任务清单

- [ ] Day 1: 创建知识库+申请权限
- [ ] Day 2: 实现WikiManager核心代码
- [ ] Day 3: 集成到message_handler
- [ ] Day 4: 完整流程测试
- [ ] Day 5: 灰度发布+收集反馈

---

## 总结

这个知识库集成项目具有：
- ✅ **技术可行性高**（飞书API成熟）
- ✅ **配额完全充足**（40万页面，100GB存储）
- ✅ **业务价值明确**（知识沉淀+用户粘性）
- ✅ **成本极低**（¥0运营成本）
- ✅ **风险可控**（有Plan B）

建议**立即启动**，采用MVP方式快速验证，成功后再扩展！🚀
