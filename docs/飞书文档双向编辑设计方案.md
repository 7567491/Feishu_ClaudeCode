# 飞书文档双向编辑机制设计方案

## 1. 总体架构

```mermaid
用户输入"编辑xx.md"
    ↓
[1] MD→飞书文档转换
    ↓
[2] 返回编辑链接 + 监听开始
    ↓
[3] 用户在飞书文档编辑
    ↓
[4] 定时/事件触发同步
    ↓
[5] 飞书文档→MD回写
    ↓
[6] 版本控制/冲突处理
```

## 2. 核心流程设计

### 2.1 编辑命令触发

```javascript
// server/lib/feishu-doc-editor.js
class FeishuDocEditor {
  constructor(feishuClient) {
    this.feishuClient = feishuClient;
    this.editSessions = new Map(); // 存储编辑会话
    this.syncInterval = 30000; // 30秒同步一次
  }

  // 解析编辑命令
  parseEditCommand(text) {
    const patterns = [
      /^编辑\s+(.+\.md)$/i,
      /^edit\s+(.+\.md)$/i,
      /^修改\s+(.+\.md)$/i
    ];

    for (const pattern of patterns) {
      const match = text.match(pattern);
      if (match) {
        return { command: 'edit', fileName: match[1] };
      }
    }
    return null;
  }

  // 启动编辑会话
  async startEditSession(chatId, mdFilePath) {
    // 1. 读取本地MD文件
    const content = await fs.promises.readFile(mdFilePath, 'utf-8');
    const fileName = path.basename(mdFilePath);

    // 2. 创建飞书文档（带编辑标识）
    const doc = await this.feishuClient.createDocumentFromMarkdown(
      `[编辑中] ${fileName}`,
      content,
      {
        setPermission: true,
        linkShareEntity: 'anyone_can_edit' // 允许任何人编辑
      }
    );

    // 3. 创建编辑会话
    const sessionId = crypto.randomUUID();
    const session = {
      sessionId,
      chatId,
      documentId: doc.document_id,
      documentUrl: doc.url,
      localPath: mdFilePath,
      originalContent: content,
      lastSyncTime: Date.now(),
      lastRevisionId: null,
      syncTimer: null,
      status: 'editing' // editing | syncing | completed | conflict
    };

    // 4. 启动同步定时器
    session.syncTimer = setInterval(
      () => this.syncDocument(sessionId),
      this.syncInterval
    );

    this.editSessions.set(sessionId, session);

    // 5. 返回编辑信息
    return {
      sessionId,
      documentUrl: doc.url,
      message: `📝 文档已创建，请点击链接编辑：${doc.url}\n⏱ 每30秒自动同步保存`
    };
  }
}
```

### 2.2 文档内容读取器

```javascript
// server/lib/feishu-doc-reader.js
class FeishuDocReader {
  constructor(feishuClient) {
    this.client = feishuClient.client;
  }

  // 读取文档全部内容并转换为Markdown
  async readDocumentAsMarkdown(documentId) {
    try {
      // 1. 获取文档的所有块
      const blocks = await this.getAllBlocks(documentId);

      // 2. 转换块为Markdown
      const markdown = this.blocksToMarkdown(blocks);

      // 3. 获取文档元信息
      const metadata = await this.getDocumentMetadata(documentId);

      return {
        content: markdown,
        revisionId: metadata.revision_id,
        lastModified: metadata.update_time
      };
    } catch (error) {
      console.error(`Failed to read document ${documentId}:`, error);
      throw error;
    }
  }

  // 获取所有文档块
  async getAllBlocks(documentId) {
    const allBlocks = [];
    let pageToken = undefined;

    do {
      const res = await this.client.docx.documentBlock.list({
        path: { document_id: documentId },
        params: {
          document_revision_id: -1, // 获取最新版本
          page_size: 500,
          page_token: pageToken
        }
      });

      if (res.code !== 0) {
        throw new Error(`Failed to list blocks: ${res.msg}`);
      }

      allBlocks.push(...(res.data?.items || []));
      pageToken = res.data?.page_token;
    } while (pageToken);

    return allBlocks;
  }

  // 将飞书块转换为Markdown
  blocksToMarkdown(blocks) {
    let markdown = '';

    for (const block of blocks) {
      const content = this.blockToMarkdown(block);
      if (content) {
        markdown += content + '\n';
      }
    }

    return markdown.trim();
  }

  // 单个块转换
  blockToMarkdown(block) {
    const { block_type, text, children } = block;

    switch (block_type) {
      case 2: // text
        return this.parseTextElements(text?.elements || []);

      case 3: // heading1
        return `# ${this.parseTextElements(text?.elements || [])}`;

      case 4: // heading2
        return `## ${this.parseTextElements(text?.elements || [])}`;

      case 5: // heading3
        return `### ${this.parseTextElements(text?.elements || [])}`;

      case 12: // bullet
        return `- ${this.parseTextElements(text?.elements || [])}`;

      case 13: // ordered
        return `1. ${this.parseTextElements(text?.elements || [])}`;

      case 14: // code
        const lang = text?.style?.language || '';
        const code = this.parseTextElements(text?.elements || []);
        return '```' + lang + '\n' + code + '\n```';

      case 15: // quote
        return `> ${this.parseTextElements(text?.elements || [])}`;

      default:
        return '';
    }
  }

  // 解析文本元素（处理加粗、斜体等格式）
  parseTextElements(elements) {
    return elements.map(element => {
      const content = element.text_run?.content || '';
      const style = element.text_run?.text_element_style || {};

      if (style.bold) {
        return `**${content}**`;
      } else if (style.italic) {
        return `*${content}*`;
      } else if (style.inline_code) {
        return `\`${content}\``;
      } else {
        return content;
      }
    }).join('');
  }

  // 获取文档元信息
  async getDocumentMetadata(documentId) {
    const res = await this.client.docx.document.get({
      path: { document_id: documentId }
    });

    if (res.code !== 0) {
      throw new Error(`Failed to get document metadata: ${res.msg}`);
    }

    return {
      title: res.data?.document?.title,
      revision_id: res.data?.document?.revision_id,
      create_time: res.data?.document?.create_time,
      update_time: res.data?.document?.update_time
    };
  }
}
```

### 2.3 同步控制器

```javascript
// server/lib/feishu-doc-sync.js
class FeishuDocSync {
  constructor(docEditor, docReader) {
    this.docEditor = docEditor;
    this.docReader = docReader;
  }

  // 同步文档内容
  async syncDocument(sessionId) {
    const session = this.docEditor.editSessions.get(sessionId);
    if (!session) return;

    try {
      session.status = 'syncing';

      // 1. 读取飞书文档最新内容
      const docContent = await this.docReader.readDocumentAsMarkdown(
        session.documentId
      );

      // 2. 检查是否有变化
      if (docContent.revisionId === session.lastRevisionId) {
        console.log(`[Sync] No changes for session ${sessionId}`);
        session.status = 'editing';
        return;
      }

      // 3. 检测冲突
      const localContent = await fs.promises.readFile(
        session.localPath,
        'utf-8'
      );

      if (localContent !== session.originalContent) {
        // 本地文件已被修改，需要处理冲突
        await this.handleConflict(session, docContent.content, localContent);
      } else {
        // 无冲突，直接写入
        await this.writeToLocal(session, docContent.content);
      }

      // 4. 更新会话状态
      session.lastRevisionId = docContent.revisionId;
      session.originalContent = docContent.content;
      session.lastSyncTime = Date.now();
      session.status = 'editing';

      console.log(`[Sync] Successfully synced session ${sessionId}`);
    } catch (error) {
      console.error(`[Sync] Error syncing session ${sessionId}:`, error);
      session.status = 'error';

      // 通知用户同步失败
      await this.notifyUser(session.chatId,
        `⚠️ 文档同步失败：${error.message}`
      );
    }
  }

  // 写入本地文件
  async writeToLocal(session, content) {
    // 1. 创建备份
    const backupPath = session.localPath + '.backup';
    const currentContent = await fs.promises.readFile(session.localPath, 'utf-8');
    await fs.promises.writeFile(backupPath, currentContent);

    // 2. 写入新内容
    await fs.promises.writeFile(session.localPath, content, 'utf-8');

    // 3. 记录同步日志
    const logEntry = {
      time: new Date().toISOString(),
      sessionId: session.sessionId,
      file: session.localPath,
      action: 'sync_from_feishu'
    };

    await this.appendSyncLog(logEntry);
  }

  // 处理冲突
  async handleConflict(session, remoteContent, localContent) {
    session.status = 'conflict';

    // 策略1：创建冲突文件
    const conflictPath = session.localPath.replace('.md', '.conflict.md');
    const conflictContent = `# 文档同步冲突

## 飞书文档版本
${remoteContent}

## 本地文件版本
${localContent}

---
冲突时间：${new Date().toLocaleString()}
会话ID：${session.sessionId}
`;

    await fs.promises.writeFile(conflictPath, conflictContent);

    // 策略2：使用三方合并（可选）
    // const merged = await this.threeWayMerge(
    //   session.originalContent,  // 基准版本
    //   remoteContent,            // 远程版本
    //   localContent              // 本地版本
    // );

    // 通知用户
    await this.notifyUser(session.chatId,
      `⚠️ 检测到编辑冲突！\n冲突文件已保存到：${conflictPath}\n请手动解决冲突。`
    );
  }

  // 停止编辑会话
  async stopEditSession(sessionId) {
    const session = this.docEditor.editSessions.get(sessionId);
    if (!session) return;

    // 1. 最后一次同步
    await this.syncDocument(sessionId);

    // 2. 清理定时器
    if (session.syncTimer) {
      clearInterval(session.syncTimer);
    }

    // 3. 标记文档标题（移除"编辑中"）
    // await this.updateDocumentTitle(session.documentId, ...);

    // 4. 移除会话
    this.docEditor.editSessions.delete(sessionId);

    return {
      success: true,
      message: `✅ 编辑会话已结束，文档已同步保存`
    };
  }
}
```

### 2.4 WebSocket实时监听（可选）

```javascript
// server/lib/feishu-doc-monitor.js
class FeishuDocMonitor {
  constructor(feishuClient) {
    this.feishuClient = feishuClient;
    this.monitors = new Map();
  }

  // 监听文档变化（使用飞书Webhook）
  async startMonitoring(documentId, callback) {
    // 方案1：定时轮询
    const pollInterval = setInterval(async () => {
      const changes = await this.checkDocumentChanges(documentId);
      if (changes) {
        callback(changes);
      }
    }, 5000); // 5秒轮询一次

    this.monitors.set(documentId, {
      interval: pollInterval,
      lastRevisionId: null
    });

    // 方案2：飞书订阅事件（需要配置Webhook）
    // await this.subscribeToDocumentEvents(documentId);
  }

  // 检查文档变化
  async checkDocumentChanges(documentId) {
    const monitor = this.monitors.get(documentId);
    if (!monitor) return null;

    const metadata = await this.feishuClient.getDocumentMetadata(documentId);

    if (metadata.revision_id !== monitor.lastRevisionId) {
      monitor.lastRevisionId = metadata.revision_id;
      return {
        documentId,
        revisionId: metadata.revision_id,
        updateTime: metadata.update_time
      };
    }

    return null;
  }

  // 停止监听
  stopMonitoring(documentId) {
    const monitor = this.monitors.get(documentId);
    if (monitor) {
      clearInterval(monitor.interval);
      this.monitors.delete(documentId);
    }
  }
}
```

## 3. 数据库表设计

```sql
-- 编辑会话表
CREATE TABLE feishu_edit_sessions (
  id TEXT PRIMARY KEY,
  chat_id TEXT NOT NULL,
  document_id TEXT NOT NULL,
  document_url TEXT NOT NULL,
  local_path TEXT NOT NULL,
  original_content TEXT,
  last_revision_id TEXT,
  last_sync_time INTEGER,
  status TEXT DEFAULT 'editing',
  created_at INTEGER DEFAULT (strftime('%s', 'now')),
  updated_at INTEGER DEFAULT (strftime('%s', 'now'))
);

-- 同步日志表
CREATE TABLE feishu_sync_logs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  session_id TEXT NOT NULL,
  action TEXT NOT NULL, -- sync_from_feishu, sync_to_feishu, conflict
  file_path TEXT NOT NULL,
  content_hash TEXT,
  error_message TEXT,
  created_at INTEGER DEFAULT (strftime('%s', 'now')),
  FOREIGN KEY (session_id) REFERENCES feishu_edit_sessions(id)
);

-- 冲突记录表
CREATE TABLE feishu_conflict_records (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  session_id TEXT NOT NULL,
  local_content TEXT,
  remote_content TEXT,
  resolved BOOLEAN DEFAULT 0,
  resolution_type TEXT, -- manual, auto_merge, use_local, use_remote
  resolved_at INTEGER,
  created_at INTEGER DEFAULT (strftime('%s', 'now'))
);
```

## 4. 集成到现有系统

### 4.1 修改消息处理器

```javascript
// server/feishu-webhook.js - 添加编辑命令处理
async handleMessageEvent(event, chatId) {
  const userText = event.message.content;

  // 检查是否为编辑命令
  const editCommand = this.docEditor.parseEditCommand(userText);
  if (editCommand) {
    const filePath = FeishuFileHandler.findFile(
      this.projectPath,
      editCommand.fileName
    );

    if (filePath) {
      const result = await this.docEditor.startEditSession(chatId, filePath);
      await this.feishuClient.sendTextMessage(chatId, result.message);
      return;
    } else {
      await this.feishuClient.sendTextMessage(
        chatId,
        `❌ 找不到文件：${editCommand.fileName}`
      );
      return;
    }
  }

  // 检查是否为停止编辑命令
  if (userText.match(/^(停止编辑|完成编辑|stop edit)/i)) {
    // 查找该聊天的活跃编辑会话
    const session = this.docEditor.findActiveSession(chatId);
    if (session) {
      const result = await this.docSync.stopEditSession(session.sessionId);
      await this.feishuClient.sendTextMessage(chatId, result.message);
    }
    return;
  }

  // ... 其他消息处理逻辑
}
```

### 4.2 添加命令提示

```javascript
// 在AI初老师或小六的帮助信息中添加
const EDIT_COMMANDS = [
  "编辑 filename.md - 创建可编辑的飞书文档并自动同步",
  "停止编辑 - 结束当前编辑会话并保存",
  "查看编辑状态 - 查看当前活跃的编辑会话"
];
```

## 5. 使用流程示例

```
用户: 编辑 README.md

系统: 📝 文档已创建，请点击链接编辑：https://feishu.cn/docx/xxx
     ⏱ 每30秒自动同步保存

[用户在飞书文档中编辑...]

[系统后台每30秒同步一次]
[2024-01-01 10:00:30] 同步成功
[2024-01-01 10:01:00] 同步成功
[2024-01-01 10:01:30] 检测到冲突，已创建冲突文件

用户: 停止编辑

系统: ✅ 编辑会话已结束，文档已同步保存
```

## 6. 高级特性（可选）

### 6.1 实时协作提醒
```javascript
// 当多人同时编辑时发送提醒
async notifyCollaborators(documentId, userId) {
  const editors = await this.getActiveEditors(documentId);
  if (editors.length > 1) {
    const message = `👥 ${editors.length}人正在编辑此文档`;
    // 发送到群聊
  }
}
```

### 6.2 版本对比
```javascript
// 显示版本差异
async showDiff(sessionId) {
  const session = this.editSessions.get(sessionId);
  const current = await fs.readFile(session.localPath, 'utf-8');
  const diff = createDiff(session.originalContent, current);
  return formatDiffAsMarkdown(diff);
}
```

### 6.3 智能冲突解决
```javascript
// 使用AI辅助解决冲突
async autoResolveConflict(base, local, remote) {
  const prompt = `请帮我合并以下三个版本的文档...`;
  const merged = await callAI(prompt);
  return merged;
}
```

## 7. 性能优化

### 7.1 增量同步
- 只同步改动的块，而不是整个文档
- 使用文档的revision_id判断是否需要同步

### 7.2 缓存机制
- 缓存文档结构，减少API调用
- 本地缓存最近的同步状态

### 7.3 批量处理
- 多个编辑会话共享同一个同步定时器
- 批量读取和写入操作

## 8. 错误处理

### 8.1 网络异常
- 自动重试机制
- 离线编辑队列

### 8.2 权限问题
- 检查文档编辑权限
- 自动请求权限升级

### 8.3 数据一致性
- 事务性操作
- 原子性写入
- 备份恢复机制

## 9. 安全考虑

### 9.1 访问控制
- 验证用户编辑权限
- 会话级别的访问控制

### 9.2 数据保护
- 敏感内容过滤
- 加密传输和存储

### 9.3 审计日志
- 记录所有编辑操作
- 追踪文档变更历史

## 10. 部署步骤

```bash
# 1. 安装依赖
npm install diff3 chokidar

# 2. 创建数据库表
sqlite3 server/database/auth.db < schema.sql

# 3. 添加环境变量
echo "FEISHU_DOC_SYNC_INTERVAL=30000" >> .env

# 4. 启动服务
npm run server

# 5. 测试编辑命令
# 在飞书群发送: 编辑 README.md
```

这个设计方案提供了完整的双向同步机制，包括冲突处理、实时监听和版本控制等高级功能。